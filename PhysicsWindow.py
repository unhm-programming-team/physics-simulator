from tkinter import *
from tkinter import ttk

import math

from Options import Options
import Physics


class PhysicsWindow:
    """
    Generated by Physics Canvas interactions.

    Window refers to the top level Tk object, the Window in Ui.py, which hosts the PhysicsCanvas.

    Window gets a reference to a PhysicsWindow so it can update if need be.
    """
    def __init__(self, window):
        self.root = Tk()
        # self.root.wm_attributes("-transparent", Options['windows transparent color'])
        # self.root['bg'] = Options['windows transparent color']
        self.window = window
        self.window.additional_windows.append(self)
        self.time_elapsed_since_last_update = 0
        self.root.protocol("WM_DELETE_WINDOW", self.del_win)
        # self.root.mainloop()

    def del_win(self):
        """
        Custom delete function also deletes window from Ui.Window update references
        """
        index = self.window.additional_windows.index(self)
        self.window.additional_windows.pop(index)
        self.root.destroy()

    def update(self, interval):
        """
        Set interval in Options.py to control how often these windows update.
        """
        self.time_elapsed_since_last_update += interval
        if self.time_elapsed_since_last_update >= Options['object popup update interval']:
            self.time_elapsed_since_last_update = 0


class ForceObjectWindow(PhysicsWindow):
    def __init__(self, window, force_object, x = 200, y=200):
        PhysicsWindow.__init__(self, window)
        self.root.geometry(f"+{round(x)}+{round(y)}")
        self.force_object = force_object

        id_label = ttk.Label(self.root, text='id: '+str(force_object.canvas_id))
        id_label.grid(row=0, column=0, sticky=W)
        material_text = f"{force_object.material.name}, {force_object.mass}kg"
        material_label = ttk.Label(self.root, text=material_text)
        material_label.grid(row=1, columnspan=4, sticky = W)
        x_label = ttk.Label(self.root, text='x: ')
        x_label.grid(row=2, column=0, sticky=E)
        self.x_val = ttk.Label(self.root)
        self.x_val.grid(row=2, column=1, sticky=W)
        y_label = ttk.Label(self.root, text='y: ')
        y_label.grid(row=2, column=2, sticky=E)
        self.y_val = ttk.Label(self.root)
        self.y_val.grid(row=2, column=3, sticky=W)
        self.velocity_label = ttk.Label(self.root)
        self.velocity_label.grid(row=3, column=0, columnspan=4, sticky=W)
        self.acceleration_label = ttk.Label(self.root)
        self.acceleration_label.grid(row=4, column=0, columnspan=4, sticky=W)
        self.net_force_label = ttk.Label(self.root)
        self.net_force_label.grid(row=5, column=0, columnspan=4, sticky=W)

        self.delete_button = ttk.Button(self.root, text='Delete', command=self.delete_button)
        self.delete_button.grid(row=3, column=4, sticky=E)

        self.add_orbiter_button = ttk.Button(self.root, text='Add Orbiter', command=self.orbiter_button)
        self.add_orbiter_button.grid(row=4, column=4, sticky=E)

        self.update(Options['object popup update interval'])
        self.root.mainloop()
        # add additional protocol to window close so it removes from open window list

    def update(self, interval):
        self.time_elapsed_since_last_update += interval
        if self.time_elapsed_since_last_update >= Options['object popup update interval']:
            self.root.lift()
            displacement = self.force_object.displacement
            x_text = f"{round(displacement.x)} m"
            y_text = f"{round(displacement.y)} m"
            self.x_val['text'] = x_text
            self.y_val['text'] = y_text
            velocity = self.force_object.velocity
            velocity_text = f"velocity: {round(velocity.magnitude)} m/s, {round(math.degrees(velocity.angle))} deg"
            self.velocity_label['text'] = velocity_text
            acceleration = self.force_object.acceleration
            acceleration_text = f"acceleration: {round(acceleration.magnitude)} m/s^2, {round(math.degrees(acceleration.angle))} deg"
            self.acceleration_label['text'] = acceleration_text
            net_force = self.force_object.net_force_vector
            net_force_text = f"net_force: {round(net_force.magnitude)} N, {round(math.degrees(net_force.angle))} deg"
            self.net_force_label['text'] = net_force_text
            self.time_elapsed_since_last_update = 0

    def delete_button(self):
        self.force_object.clear_forces()
        self.window.physics_canvas.delete_physics_object(self.force_object)
        self.del_win()

    def orbiter_button(self):
        planet = self.force_object
        gravitational_constant = 6.67*10**(-11)
        orbital_radius = 100
        new_mass = planet.mass/100
        material = planet.material
        force_magnitude = (gravitational_constant * planet.mass * new_mass)/orbital_radius**2
        moon_radial_acceleration = new_mass/force_magnitude
        orbital_velocity = 10
        moon = Physics.ForceObject(self.window.physics_canvas, material, new_mass)
        moon_x = planet.displacement.x
        moon_y = planet.displacement.y - orbital_radius
        moon.displacement = Physics.Vector.make_vector_from_components(moon_x,moon_y)
        moon.velocity = Physics.Vector.make_directional_vector('W', orbital_velocity)
        moon.calculate_bounds()
        self.window.physics_canvas.add_force_object(moon)
        grav = Physics.GravitationalForceGenerator(planet, moon)
        self.window.physics_canvas.interacting_forces.append(grav)
        self.window.log('added orbiter')


class AddObjectWindow:
    def __init__(self):
        pass